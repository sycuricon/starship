diff --git a/riscv/csrs.cc b/riscv/csrs.cc
index 0eee40de..78f7de54 100644
--- a/riscv/csrs.cc
+++ b/riscv/csrs.cc
@@ -1688,3 +1688,13 @@ bool smcntrpmf_csr_t::unlogged_write(const reg_t val) noexcept {
   prev_val = read();
   return masked_csr_t::unlogged_write(val);
 }
+
+key_csr_t::key_csr_t(processor_t* const proc, const reg_t addr, const reg_t init):
+  csr_t(proc, addr),
+  val(init) {
+}
+
+bool key_csr_t::unlogged_write(const reg_t val) noexcept {
+  this->val = val;
+  return true;
+}
\ No newline at end of file
diff --git a/riscv/csrs.h b/riscv/csrs.h
index efa7f10a..be0e61ff 100644
--- a/riscv/csrs.h
+++ b/riscv/csrs.h
@@ -842,4 +842,19 @@ class smcntrpmf_csr_t : public masked_csr_t {
  private:
   std::optional<reg_t> prev_val;
 };
+
+class key_csr_t: public csr_t {
+ public:
+  key_csr_t(processor_t* const proc, const reg_t addr, const reg_t init);
+
+  virtual reg_t read() const noexcept override {
+    return val;
+  }
+
+ protected:
+  virtual bool unlogged_write(const reg_t val) noexcept override;
+ private:
+  reg_t val;
+};
+
 #endif
diff --git a/riscv/decode.h b/riscv/decode.h
index f7ca8e87..e2df55f5 100644
--- a/riscv/decode.h
+++ b/riscv/decode.h
@@ -93,6 +93,8 @@ public:
   uint64_t iorw() { return x(20, 8); }
   uint64_t bs() { return x(30, 2); } // Crypto ISE - SM4/AES32 byte select.
   uint64_t rcon() { return x(20, 4); } // Crypto ISE - AES64 round const.
+  uint64_t rgvlt_startb() { return x(26, 3); }
+  uint64_t rgvlt_endb() { return x(29, 3); }
 
   int64_t rvc_imm() { return x(2, 5) + (xs(12, 1) << 5); }
   int64_t rvc_zimm() { return x(2, 5) + (x(12, 1) << 5); }
diff --git a/riscv/encoding.h b/riscv/encoding.h
index a7e2d945..7fe37074 100644
--- a/riscv/encoding.h
+++ b/riscv/encoding.h
@@ -4,7 +4,7 @@
 
 /*
  * This file is auto-generated by running 'make' in
- * https://github.com/riscv/riscv-opcodes (d752f19)
+ * https://github.com/riscv/riscv-opcodes (61d2ef4)
  */
 
 #ifndef RISCV_CSR_ENCODING_H
@@ -29,6 +29,7 @@
 #define MSTATUS_TVM         0x00100000
 #define MSTATUS_TW          0x00200000
 #define MSTATUS_TSR         0x00400000
+#define MSTATUS_SPELP       0x00800000
 #define MSTATUS32_SD        0x80000000
 #define MSTATUS_UXL         0x0000000300000000
 #define MSTATUS_SXL         0x0000000C00000000
@@ -36,6 +37,7 @@
 #define MSTATUS_MBE         0x0000002000000000
 #define MSTATUS_GVA         0x0000004000000000
 #define MSTATUS_MPV         0x0000008000000000
+#define MSTATUS_MPELP       0x0000020000000000
 #define MSTATUS64_SD        0x8000000000000000
 
 #define MSTATUSH_SBE        0x00000010
@@ -54,6 +56,7 @@
 #define SSTATUS_XS          0x00018000
 #define SSTATUS_SUM         0x00040000
 #define SSTATUS_MXR         0x00080000
+#define SSTATUS_SPELP       0x00800000
 #define SSTATUS32_SD        0x80000000
 #define SSTATUS_UXL         0x0000000300000000
 #define SSTATUS64_SD        0x8000000000000000
@@ -79,6 +82,7 @@
 #define DCSR_XDEBUGVER      (3U<<30)
 #define DCSR_NDRESET        (1<<29)
 #define DCSR_FULLRESET      (1<<28)
+#define DCSR_PELP           (1<<18)
 #define DCSR_EBREAKM        (1<<15)
 #define DCSR_EBREAKH        (1<<14)
 #define DCSR_EBREAKS        (1<<13)
@@ -157,6 +161,8 @@
 #define SIP_STIP MIP_STIP
 
 #define MENVCFG_FIOM  0x00000001
+#define MENVCFG_LPE   0x00000004
+#define MENVCFG_SSE   0x00000008
 #define MENVCFG_CBIE  0x00000030
 #define MENVCFG_CBCFE 0x00000040
 #define MENVCFG_CBZE  0x00000080
@@ -195,6 +201,8 @@
 #define MHPMEVENTH_OF    0x80000000
 
 #define HENVCFG_FIOM  0x00000001
+#define HENVCFG_LPE   0x00000004
+#define HENVCFG_SSE   0x00000008
 #define HENVCFG_CBIE  0x00000030
 #define HENVCFG_CBCFE 0x00000040
 #define HENVCFG_CBZE  0x00000080
@@ -230,6 +238,8 @@
 #define HSTATEENH_SSTATEEN  0x80000000
 
 #define SENVCFG_FIOM  0x00000001
+#define SENVCFG_LPE   0x00000004
+#define SENVCFG_SSE   0x00000008
 #define SENVCFG_CBIE  0x00000030
 #define SENVCFG_CBCFE 0x00000040
 #define SENVCFG_CBZE  0x00000080
@@ -243,6 +253,7 @@
 #define MSECCFG_RLB    0x00000004
 #define MSECCFG_USEED  0x00000100
 #define MSECCFG_SSEED  0x00000200
+#define MSECCFG_MLPE   0x00000400
 
 /* jvt fields */
 #define JVT_MODE   0x3F
@@ -624,6 +635,10 @@
 #define MASK_C_SRAI 0xec03
 #define MATCH_C_SRLI 0x8001
 #define MASK_C_SRLI 0xec03
+#define MATCH_C_SSPOPCHK_X5 0x6281
+#define MASK_C_SSPOPCHK_X5 0xffff
+#define MATCH_C_SSPUSH_X1 0x6081
+#define MASK_C_SSPUSH_X1 0xffff
 #define MATCH_C_SUB 0x8c01
 #define MASK_C_SUB 0xfc63
 #define MATCH_C_SUBW 0x9c01
@@ -716,6 +731,10 @@
 #define MASK_CRC32C_H 0xfff0707f
 #define MATCH_CRC32C_W 0x61a01013
 #define MASK_CRC32C_W 0xfff0707f
+#define MATCH_CRDXK 0x200006b
+#define MASK_CRDXK 0x200007f
+#define MATCH_CREXK 0x6b
+#define MASK_CREXK 0x200007f
 #define MATCH_CRSA16 0x46000077
 #define MASK_CRSA16 0xfe00707f
 #define MATCH_CRSA32 0x46002077
@@ -1834,6 +1853,20 @@
 #define MASK_SROIW 0xfe00707f
 #define MATCH_SROW 0x2000503b
 #define MASK_SROW 0xfe00707f
+#define MATCH_SSAMOSWAP_D 0x4800302f
+#define MASK_SSAMOSWAP_D 0xf800707f
+#define MATCH_SSAMOSWAP_W 0x4800202f
+#define MASK_SSAMOSWAP_W 0xf800707f
+#define MATCH_SSPOPCHK_X1 0xcdc0c073
+#define MASK_SSPOPCHK_X1 0xffffffff
+#define MATCH_SSPOPCHK_X5 0xcdc2c073
+#define MASK_SSPOPCHK_X5 0xffffffff
+#define MATCH_SSPUSH_X1 0xce104073
+#define MASK_SSPUSH_X1 0xffffffff
+#define MATCH_SSPUSH_X5 0xce504073
+#define MASK_SSPUSH_X5 0xffffffff
+#define MATCH_SSRDP 0xcdc04073
+#define MASK_SSRDP 0xfffff07f
 #define MATCH_STAS16 0xf4002077
 #define MASK_STAS16 0xfe00707f
 #define MATCH_STAS32 0xf0002077
@@ -3016,6 +3049,7 @@
 #define CSR_VXSAT 0x9
 #define CSR_VXRM 0xa
 #define CSR_VCSR 0xf
+#define CSR_SSP 0x11
 #define CSR_SEED 0x15
 #define CSR_JVT 0x17
 #define CSR_CYCLE 0xc00
@@ -3331,6 +3365,22 @@
 #define CSR_MHARTID 0xf14
 #define CSR_MCONFIGPTR 0xf15
 #define CSR_MTOPI 0xfb0
+#define CSR_MCRMKEYL 0x7f0
+#define CSR_MCRMKEYH 0x7f1
+#define CSR_SCRTKEYL 0x5f0
+#define CSR_SCRTKEYH 0x5f1
+#define CSR_SCRAKEYL 0x5f2
+#define CSR_SCRAKEYH 0x5f3
+#define CSR_SCRBKEYL 0x5f4
+#define CSR_SCRBKEYH 0x5f5
+#define CSR_SCRCKEYL 0x5f6
+#define CSR_SCRCKEYH 0x5f7
+#define CSR_SCRDKEYL 0x5f8
+#define CSR_SCRDKEYH 0x5f9
+#define CSR_SCREKEYL 0x5fa
+#define CSR_SCREKEYH 0x5fb
+#define CSR_SCRFKEYL 0x5fc
+#define CSR_SCRFKEYH 0x5fd
 #define CSR_SIEH 0x114
 #define CSR_SIPH 0x154
 #define CSR_STIMECMPH 0x15d
@@ -3474,6 +3524,8 @@
 #define CAUSE_FETCH_PAGE_FAULT 0xc
 #define CAUSE_LOAD_PAGE_FAULT 0xd
 #define CAUSE_STORE_PAGE_FAULT 0xf
+#define CAUSE_SOFTWARE_CHECK_FAULT 0x12
+#define CAUSE_HARDWARE_ERROR_FAULT 0x13
 #define CAUSE_FETCH_GUEST_PAGE_FAULT 0x14
 #define CAUSE_LOAD_GUEST_PAGE_FAULT 0x15
 #define CAUSE_VIRTUAL_INSTRUCTION 0x16
@@ -3702,6 +3754,8 @@ DECLARE_INSN(c_sq, MATCH_C_SQ, MASK_C_SQ)
 DECLARE_INSN(c_sqsp, MATCH_C_SQSP, MASK_C_SQSP)
 DECLARE_INSN(c_srai, MATCH_C_SRAI, MASK_C_SRAI)
 DECLARE_INSN(c_srli, MATCH_C_SRLI, MASK_C_SRLI)
+DECLARE_INSN(c_sspopchk_x5, MATCH_C_SSPOPCHK_X5, MASK_C_SSPOPCHK_X5)
+DECLARE_INSN(c_sspush_x1, MATCH_C_SSPUSH_X1, MASK_C_SSPUSH_X1)
 DECLARE_INSN(c_sub, MATCH_C_SUB, MASK_C_SUB)
 DECLARE_INSN(c_subw, MATCH_C_SUBW, MASK_C_SUBW)
 DECLARE_INSN(c_sw, MATCH_C_SW, MASK_C_SW)
@@ -3748,6 +3802,8 @@ DECLARE_INSN(crc32c_b, MATCH_CRC32C_B, MASK_CRC32C_B)
 DECLARE_INSN(crc32c_d, MATCH_CRC32C_D, MASK_CRC32C_D)
 DECLARE_INSN(crc32c_h, MATCH_CRC32C_H, MASK_CRC32C_H)
 DECLARE_INSN(crc32c_w, MATCH_CRC32C_W, MASK_CRC32C_W)
+DECLARE_INSN(crdxk, MATCH_CRDXK, MASK_CRDXK)
+DECLARE_INSN(crexk, MATCH_CREXK, MASK_CREXK)
 DECLARE_INSN(crsa16, MATCH_CRSA16, MASK_CRSA16)
 DECLARE_INSN(crsa32, MATCH_CRSA32, MASK_CRSA32)
 DECLARE_INSN(csrrc, MATCH_CSRRC, MASK_CSRRC)
@@ -4307,6 +4363,13 @@ DECLARE_INSN(sro, MATCH_SRO, MASK_SRO)
 DECLARE_INSN(sroi, MATCH_SROI, MASK_SROI)
 DECLARE_INSN(sroiw, MATCH_SROIW, MASK_SROIW)
 DECLARE_INSN(srow, MATCH_SROW, MASK_SROW)
+DECLARE_INSN(ssamoswap_d, MATCH_SSAMOSWAP_D, MASK_SSAMOSWAP_D)
+DECLARE_INSN(ssamoswap_w, MATCH_SSAMOSWAP_W, MASK_SSAMOSWAP_W)
+DECLARE_INSN(sspopchk_x1, MATCH_SSPOPCHK_X1, MASK_SSPOPCHK_X1)
+DECLARE_INSN(sspopchk_x5, MATCH_SSPOPCHK_X5, MASK_SSPOPCHK_X5)
+DECLARE_INSN(sspush_x1, MATCH_SSPUSH_X1, MASK_SSPUSH_X1)
+DECLARE_INSN(sspush_x5, MATCH_SSPUSH_X5, MASK_SSPUSH_X5)
+DECLARE_INSN(ssrdp, MATCH_SSRDP, MASK_SSRDP)
 DECLARE_INSN(stas16, MATCH_STAS16, MASK_STAS16)
 DECLARE_INSN(stas32, MATCH_STAS32, MASK_STAS32)
 DECLARE_INSN(stsa16, MATCH_STSA16, MASK_STSA16)
@@ -4903,6 +4966,7 @@ DECLARE_CSR(vstart, CSR_VSTART)
 DECLARE_CSR(vxsat, CSR_VXSAT)
 DECLARE_CSR(vxrm, CSR_VXRM)
 DECLARE_CSR(vcsr, CSR_VCSR)
+DECLARE_CSR(ssp, CSR_SSP)
 DECLARE_CSR(seed, CSR_SEED)
 DECLARE_CSR(jvt, CSR_JVT)
 DECLARE_CSR(cycle, CSR_CYCLE)
@@ -5218,6 +5282,22 @@ DECLARE_CSR(mimpid, CSR_MIMPID)
 DECLARE_CSR(mhartid, CSR_MHARTID)
 DECLARE_CSR(mconfigptr, CSR_MCONFIGPTR)
 DECLARE_CSR(mtopi, CSR_MTOPI)
+DECLARE_CSR(mcrmkeyl, CSR_MCRMKEYL)
+DECLARE_CSR(mcrmkeyh, CSR_MCRMKEYH)
+DECLARE_CSR(scrtkeyl, CSR_SCRTKEYL)
+DECLARE_CSR(scrtkeyh, CSR_SCRTKEYH)
+DECLARE_CSR(scrakeyl, CSR_SCRAKEYL)
+DECLARE_CSR(scrakeyh, CSR_SCRAKEYH)
+DECLARE_CSR(scrbkeyl, CSR_SCRBKEYL)
+DECLARE_CSR(scrbkeyh, CSR_SCRBKEYH)
+DECLARE_CSR(scrckeyl, CSR_SCRCKEYL)
+DECLARE_CSR(scrckeyh, CSR_SCRCKEYH)
+DECLARE_CSR(scrdkeyl, CSR_SCRDKEYL)
+DECLARE_CSR(scrdkeyh, CSR_SCRDKEYH)
+DECLARE_CSR(screkeyl, CSR_SCREKEYL)
+DECLARE_CSR(screkeyh, CSR_SCREKEYH)
+DECLARE_CSR(scrfkeyl, CSR_SCRFKEYL)
+DECLARE_CSR(scrfkeyh, CSR_SCRFKEYH)
 DECLARE_CSR(sieh, CSR_SIEH)
 DECLARE_CSR(siph, CSR_SIPH)
 DECLARE_CSR(stimecmph, CSR_STIMECMPH)
@@ -5362,6 +5442,8 @@ DECLARE_CAUSE("machine_ecall", CAUSE_MACHINE_ECALL)
 DECLARE_CAUSE("fetch page fault", CAUSE_FETCH_PAGE_FAULT)
 DECLARE_CAUSE("load page fault", CAUSE_LOAD_PAGE_FAULT)
 DECLARE_CAUSE("store page fault", CAUSE_STORE_PAGE_FAULT)
+DECLARE_CAUSE("software check fault", CAUSE_SOFTWARE_CHECK_FAULT)
+DECLARE_CAUSE("hardware error fault", CAUSE_HARDWARE_ERROR_FAULT)
 DECLARE_CAUSE("fetch guest page fault", CAUSE_FETCH_GUEST_PAGE_FAULT)
 DECLARE_CAUSE("load guest page fault", CAUSE_LOAD_GUEST_PAGE_FAULT)
 DECLARE_CAUSE("virtual instruction", CAUSE_VIRTUAL_INSTRUCTION)
diff --git a/riscv/insn_template.h b/riscv/insn_template.h
index cead6d7d..2f2112ad 100644
--- a/riscv/insn_template.h
+++ b/riscv/insn_template.h
@@ -9,4 +9,5 @@
 #include "tracer.h"
 #include "p_ext_macros.h"
 #include "v_ext_macros.h"
+#include "qarma.h"
 #include <assert.h>
diff --git a/riscv/insns/crdxk.h b/riscv/insns/crdxk.h
new file mode 100644
index 00000000..602e7c43
--- /dev/null
+++ b/riscv/insns/crdxk.h
@@ -0,0 +1,78 @@
+// #include "qarma.h"
+uint64_t sel_key = insn.rm();
+uint64_t startbit = insn.rgvlt_startb() * 8;
+uint64_t endbit = (insn.rgvlt_endb() + 1) * 8 - 1;
+uint64_t totbits = endbit - startbit + 1;
+
+if (endbit < startbit)
+    throw trap_illegal_instruction(insn.bits());
+
+uint64_t cipher = RS1;
+uint64_t tweak = RS2;
+int keyl = 0;
+int keyh = 0;
+
+int round = 7;
+
+switch (sel_key)
+{
+case 0:
+    /* stkey */
+    keyl = 0x5F0;
+    keyh = 0x5F1;
+    break;
+case 1:
+    /* mkey */
+    keyl = 0x7F0;
+    keyh = 0x7F1;
+    break;
+case 2:
+    /* sakey */
+    keyl = 0x5F2;
+    keyh = 0x5F3;
+    break;
+case 3:
+    /* sbkey */
+    keyl = 0x5F4;
+    keyh = 0x5F5;
+    break;
+case 4:
+    /* sckey */
+    keyl = 0x5F6;
+    keyh = 0x5F7;
+    break;
+case 5:
+    /* sdkey */
+    keyl = 0x5F8;
+    keyh = 0x5F9;
+    break;
+case 6:
+    /* sekey */
+    keyl = 0x5Fa;
+    keyh = 0x5Fb;
+    break;
+case 7:
+    /* sfkey */
+    keyl = 0x5Fc;
+    keyh = 0x5Fd;
+    break;
+
+default:
+    throw trap_illegal_instruction(insn.bits());
+    break;
+}
+// keyh = 0x5f1;
+// keyl = 0x5f0;
+
+uint64_t w0 = sext_xlen(p->get_csr(keyh, insn, false));
+uint64_t k0 = sext_xlen(p->get_csr(keyl, insn, false));
+uint64_t plain = qarma64_dec(cipher, tweak, w0, k0, round);
+
+uint64_t mask = totbits == 64 ? ~(uint64_t)0 :\
+    ((((uint64_t)1 << totbits) - 1) << startbit);
+uint64_t text = plain & mask;
+
+// if (text != plain)
+//     throw trap_illegal_instruction(insn.bits());
+
+WRITE_RD(plain);
diff --git a/riscv/insns/crexk.h b/riscv/insns/crexk.h
new file mode 100644
index 00000000..79b1c504
--- /dev/null
+++ b/riscv/insns/crexk.h
@@ -0,0 +1,74 @@
+// #include "qarma.h"
+uint64_t sel_key = insn.rm();
+uint64_t startbit = insn.rgvlt_startb() * 8;
+uint64_t endbit = (insn.rgvlt_endb() + 1) * 8 - 1;
+
+if (endbit < startbit)
+    throw trap_illegal_instruction(insn.bits());
+
+uint64_t totbits = endbit - startbit + 1;
+uint64_t mask = totbits == 64 ? ~(uint64_t)0 :\
+    ((((uint64_t)1 << totbits) - 1) << startbit);
+uint64_t plain = RS1;
+uint64_t text = plain & mask;
+
+uint64_t tweak = RS2;
+
+int keyl = 0;
+int keyh = 0;
+int round = 7;
+
+switch (sel_key)
+{
+case 0:
+    /* stkey */
+    keyl = 0x5F0;
+    keyh = 0x5F1;
+    break;
+case 1:
+    /* mkey */
+    keyl = 0x7F0;
+    keyh = 0x7F1;
+    break;
+case 2:
+    /* sakey */
+    keyl = 0x5F2;
+    keyh = 0x5F3;
+    break;
+case 3:
+    /* sbkey */
+    keyl = 0x5F4;
+    keyh = 0x5F5;
+    break;
+case 4:
+    /* sckey */
+    keyl = 0x5F6;
+    keyh = 0x5F7;
+    break;
+case 5:
+    /* sdkey */
+    keyl = 0x5F8;
+    keyh = 0x5F9;
+    break;
+case 6:
+    /* sekey */
+    keyl = 0x5Fa;
+    keyh = 0x5Fb;
+    break;
+case 7:
+    /* sfkey */
+    keyl = 0x5Fc;
+    keyh = 0x5Fd;
+    break;
+
+default:
+    throw trap_illegal_instruction(insn.bits());
+    break;
+}
+// keyh = 0x5f1;
+// keyl = 0x5f0;
+
+uint64_t w0 = sext_xlen(p->get_csr(keyh, insn, false));
+uint64_t k0 = sext_xlen(p->get_csr(keyl, insn, false));
+uint64_t cipher = qarma64_enc(text, tweak, w0, k0, round);
+WRITE_RD(cipher);
diff --git a/riscv/processor.cc b/riscv/processor.cc
index 51c9bd88..d7afc9d4 100644
--- a/riscv/processor.cc
+++ b/riscv/processor.cc
@@ -585,6 +585,23 @@ void state_t::reset(processor_t* const proc, reg_t max_isa)
       }
   }
 
+  csrmap[CSR_MCRMKEYH] = std::make_shared<key_csr_t>(proc, CSR_MCRMKEYH, 0);
+  csrmap[CSR_MCRMKEYL] = std::make_shared<key_csr_t>(proc, CSR_MCRMKEYL, 0);
+  csrmap[CSR_SCRAKEYH] = std::make_shared<key_csr_t>(proc, CSR_SCRAKEYH, 0);
+  csrmap[CSR_SCRAKEYL] = std::make_shared<key_csr_t>(proc, CSR_SCRAKEYL, 0);
+  csrmap[CSR_SCRBKEYH] = std::make_shared<key_csr_t>(proc, CSR_SCRBKEYH, 0);
+  csrmap[CSR_SCRBKEYL] = std::make_shared<key_csr_t>(proc, CSR_SCRBKEYL, 0);
+  csrmap[CSR_SCRCKEYH] = std::make_shared<key_csr_t>(proc, CSR_SCRCKEYH, 0);
+  csrmap[CSR_SCRCKEYL] = std::make_shared<key_csr_t>(proc, CSR_SCRCKEYL, 0);
+  csrmap[CSR_SCRDKEYH] = std::make_shared<key_csr_t>(proc, CSR_SCRDKEYH, 0);
+  csrmap[CSR_SCRDKEYL] = std::make_shared<key_csr_t>(proc, CSR_SCRDKEYL, 0);
+  csrmap[CSR_SCREKEYH] = std::make_shared<key_csr_t>(proc, CSR_SCREKEYH, 0);
+  csrmap[CSR_SCREKEYL] = std::make_shared<key_csr_t>(proc, CSR_SCREKEYL, 0);
+  csrmap[CSR_SCRFKEYH] = std::make_shared<key_csr_t>(proc, CSR_SCRFKEYH, 0);
+  csrmap[CSR_SCRFKEYL] = std::make_shared<key_csr_t>(proc, CSR_SCRFKEYL, 0);
+  csrmap[CSR_SCRTKEYH] = std::make_shared<key_csr_t>(proc, CSR_SCRTKEYH, 0);
+  csrmap[CSR_SCRTKEYL] = std::make_shared<key_csr_t>(proc, CSR_SCRTKEYL, 0);
+
   serialized = false;
 
   log_reg_write.clear();
diff --git a/riscv/processor.h b/riscv/processor.h
index 0a073adf..21b8a3ed 100644
--- a/riscv/processor.h
+++ b/riscv/processor.h
@@ -113,6 +113,22 @@ struct state_t
   csr_t_p stvec;
   virtualized_csr_t_p satp;
   csr_t_p scause;
+  csr_t_p mcrmkeyh;
+  csr_t_p mcrmkeyl;
+  csr_t_p scrakeyh;
+  csr_t_p scrakeyl;
+  csr_t_p scrbkeyh;
+  csr_t_p scrbkeyl;
+  csr_t_p scrckeyh;
+  csr_t_p scrckeyl;
+  csr_t_p scrdkeyh;
+  csr_t_p scrdkeyl;
+  csr_t_p screkeyh;
+  csr_t_p screkeyl;
+  csr_t_p scrfkeyh;
+  csr_t_p scrfkeyl;
+  csr_t_p scrtkeyh;
+  csr_t_p scrtkeyl;
 
   // When taking a trap into HS-mode, we must access the nonvirtualized HS-mode CSRs directly:
   csr_t_p nonvirtual_stvec;
diff --git a/riscv/qarma.cc b/riscv/qarma.cc
new file mode 100644
index 00000000..83aa52f5
--- /dev/null
+++ b/riscv/qarma.cc
@@ -0,0 +1,303 @@
+#include "qarma.h"
+
+int sbox_use = 2;
+text_t check_box[3] = { 0xc003b93999b33765, 0x270a787275c48d10, 0x5c06a7501b63b2fd };
+
+
+int m = MAX_LENGTH / 16;
+
+const_t alpha = 0xC0AC29B7C97C50DD;
+const_t c[8] = { 0x0000000000000000, 0x13198A2E03707344, 0xA4093822299F31D0, 0x082EFA98EC4E6C89,
+				 0x452821E638D01377, 0xBE5466CF34E90C6C, 0x3F84D5B5B5470917, 0x9216D5D98979FB1B };
+
+int sbox[3][16] = { { 0, 14,  2, 10,  9, 15,  8, 11,  6,  4,  3,  7, 13, 12,  1,  5},
+					{10, 13, 14,  6, 15,  7,  3,  5,  9,  8,  0, 12, 11,  1,  2,  4},
+					{11,  6,  8, 15, 12,  0,  9, 14,  3,  7,  4,  5, 13,  2,  1, 10} };
+
+int sbox_inv[3][16] = { { 0, 14,  2, 10,  9, 15,  8, 11,  6,  4,  3,  7, 13, 12,  1,  5},
+						{10, 13, 14,  6, 15,  7,  3,  5,  9,  8,  0, 12, 11,  1,  2,  4},
+						{ 5, 14, 13,  8, 10, 11,  1,  9,  2,  6, 15,  0,  4, 12,  7,  3} };
+
+int t[16] = { 0, 11,  6, 13, 10,  1, 12,  7,  5, 14,  3,  8, 15,  4,  9,  2 };
+int t_inv[16] = { 0,  5, 15, 10, 13,  8,  2,  7, 11, 14,  4,  1,  6,  3,  9, 12 };
+int h[16] = { 6,  5, 14, 15,  0,  1,  2,  3,  7, 12, 13,  4,  8,  9, 10, 11 };
+int h_inv[16] = { 4,  5,  6,  7, 11,  1,  0,  8, 12, 13, 14, 15,  9, 10,  2,  3 };
+
+#define Q M
+#define M_inv M
+cell_t M[16] = { 0, 1, 2, 1,
+				 1, 0, 1, 2,
+				 2, 1, 0, 1,
+				 1, 2, 1, 0 };
+
+void text2cell(cell_t* cell, text_t is) {
+	// for 64 bits
+	char* byte_ptr = (char*)&is;
+	for (int i = 0; i < MAX_LENGTH / 8; i++) {
+		char byte = byte_ptr[i];
+		cell[2 * (7 - i) + 0] = (byte & 0xF0) >> 4;
+		cell[2 * (7 - i) + 1] = byte & 0xF;
+	}
+}
+
+text_t cell2text(cell_t* cell) {
+	text_t is = 0;
+	for (int i = 0; i < MAX_LENGTH / 8; i++) {
+		text_t byte = 0;
+		byte = (cell[2 * i] << 4) | cell[2 * i + 1];
+		is = is | (byte << (7 - i) * 8UL);
+	}
+	return is;
+}
+
+text_t pseudo_reflect(text_t is, qkey_t tk) {
+	cell_t cell[16];
+	text2cell(cell, is);
+
+	// ShuffleCells
+	cell_t perm[16];
+	for (int i = 0; i < 16; i++)
+		perm[i] = cell[t[i]];
+
+	// MixColumns
+	for (int x = 0; x < 4; x++) {
+		for (int y = 0; y < 4; y++) {
+			cell_t temp = 0;
+			for (int j = 0; j < 4; j++) {
+				int b;
+				if (b = Q[4 * x + j]) {
+					cell_t a = perm[4 * j + y];
+					temp ^= ((a << b) & 0x0F) | (a >> (4 - b));
+				}
+			}
+			cell[4 * x + y] = temp;
+		}
+	}
+
+	// AddRoundTweakey
+	for (int i = 0; i < 16; i++)
+		cell[i] ^= (tk >> (4 * (15 - i))) & 0xF;
+
+	// ShuffleCells invert
+	for (int i = 0; i < 16; i++)
+		perm[i] = cell[t_inv[i]];
+
+	return cell2text(perm);
+}
+
+text_t forward(text_t is, qkey_t tk, int r) {
+	//printf("key = 0x%016llx\n", tk);
+
+	is ^= tk;
+	cell_t cell[16];
+	text2cell(cell, is);
+	//printf("0x%016llx\n", is);
+
+
+	if (r != 0) {
+		// ShuffleCells
+		cell_t perm[16];
+		for (int i = 0; i < 16; i++)
+			perm[i] = cell[t[i]];
+
+		// MixColumns
+		for (int x = 0; x < 4; x++) {
+			for (int y = 0; y < 4; y++) {
+				cell_t temp = 0;
+				for (int j = 0; j < 4; j++) {
+					int b;
+					if (b = M[4 * x + j]) {
+						cell_t a = perm[4 * j + y];
+						temp ^= ((a << b) & 0x0F) | (a >> (4 - b));
+					}
+				}
+				cell[4 * x + y] = temp;
+			}
+		}
+	}
+
+	// SubCells
+	for (int i = 0; i < 16; i++) {
+		cell[i] = subcells[cell[i]];
+	}
+	is = cell2text(cell);
+	//printf("0x%016llx\n", is);
+
+	return is;
+}
+
+text_t backward(text_t is, qkey_t tk, int r) {
+	cell_t cell[16];
+	text2cell(cell, is);
+	//printf("0x%016llx\n", is);
+
+	// SubCells
+	for (int i = 0; i < 16; i++) {
+		cell[i] = subcells_inv[cell[i]];
+	}
+	//printf("key = 0x%016llx\n", tk);
+
+	if (r != 0) {
+		cell_t mixc[16];
+		// MixColumns
+		for (int x = 0; x < 4; x++) {
+			for (int y = 0; y < 4; y++) {
+				cell_t temp = 0;
+				for (int j = 0; j < 4; j++) {
+					int b;
+					if (b = M_inv[4 * x + j]) {
+						cell_t a = cell[4 * j + y];
+						temp ^= ((a << b) & 0x0F) | (a >> (4 - b));
+					}
+				}
+				mixc[4 * x + y] = temp;
+			}
+		}
+
+		// ShuffleCells
+		for (int i = 0; i < 16; i++)
+			cell[i] = mixc[t_inv[i]];
+	}
+
+	is = cell2text(cell);
+	is ^= tk;
+	//printf("0x%016llx\n", is);
+	return is;
+}
+
+cell_t LFSR(cell_t x) {
+	cell_t b0 = (x >> 0) & 1;
+	cell_t b1 = (x >> 1) & 1;
+	cell_t b2 = (x >> 2) & 1;
+	cell_t b3 = (x >> 3) & 1;
+
+	return ((b0 ^ b1) << 3) | (b3 << 2) | (b2 << 1) | (b1 << 0);
+}
+
+cell_t LFSR_inv(cell_t x) {
+	cell_t b0 = (x >> 0) & 1;
+	cell_t b1 = (x >> 1) & 1;
+	cell_t b2 = (x >> 2) & 1;
+	cell_t b3 = (x >> 3) & 1;
+
+	return ((b0 ^ b3) << 0) | (b0 << 1) | (b1 << 2) | (b2 << 3);
+}
+
+qkey_t forward_update_key(qkey_t T) {
+	cell_t cell[16], temp[16];
+	text2cell(cell, T);
+
+	// h box
+	for (int i = 0; i < 16; i++) {
+		temp[i] = cell[h[i]];
+	}
+
+	// w LFSR
+	temp[0] = LFSR(temp[0]);
+	temp[1] = LFSR(temp[1]);
+	temp[3] = LFSR(temp[3]);
+	temp[4] = LFSR(temp[4]);
+	temp[8] = LFSR(temp[8]);
+	temp[11] = LFSR(temp[11]);
+	temp[13] = LFSR(temp[13]);
+
+	return cell2text(temp);
+}
+
+qkey_t backward_update_key(qkey_t T) {
+	cell_t cell[16], temp[16];
+	text2cell(cell, T);
+
+	// w LFSR invert
+	cell[0] = LFSR_inv(cell[0]);
+	cell[1] = LFSR_inv(cell[1]);
+	cell[3] = LFSR_inv(cell[3]);
+	cell[4] = LFSR_inv(cell[4]);
+	cell[8] = LFSR_inv(cell[8]);
+	cell[11] = LFSR_inv(cell[11]);
+	cell[13] = LFSR_inv(cell[13]);
+
+	// h box
+	for (int i = 0; i < 16; i++) {
+		temp[i] = cell[h_inv[i]];
+	}
+
+	return cell2text(temp);
+}
+
+text_t qarma64_enc(text_t plaintext, tweak_t tweak, qkey_t w0, qkey_t k0, int rounds) {
+	qkey_t w1 = ((w0 >> 1) | (w0 << (64 - 1))) ^ (w0 >> (16 * m - 1));
+	qkey_t k1 = k0;
+
+	text_t is = plaintext ^ w0;
+
+	for (int i = 0; i < rounds; i++) {
+		//printf("%d:\n", i);
+		is = forward(is, k0 ^ tweak ^ c[i], i);
+		tweak = forward_update_key(tweak);
+	}
+
+	//printf("0x%016llx\n", is);
+	is = forward(is, w1 ^ tweak, 1);
+	is = pseudo_reflect(is, k1);
+	is = backward(is, w0 ^ tweak, 1);
+
+	for (int i = rounds - 1; i >= 0; i--) {
+		//printf("%d:\n", i);
+		tweak = backward_update_key(tweak);
+		is = backward(is, k0 ^ tweak ^ c[i] ^ alpha, i);
+	}
+
+	is ^= w1;
+	//printf("0x%016llx\n", is);
+	return is;
+}
+
+text_t qarma64_dec(text_t plaintext, tweak_t tweak, qkey_t w0, qkey_t k0, int rounds) {
+
+	qkey_t w1 = w0;
+	w0 = ((w0 >> 1) | (w0 << (64 - 1))) ^ (w0 >> (16 * m - 1));
+
+	cell_t k0_cell[16], k1_cell[16];
+	text2cell(k0_cell, k0);
+	// MixColumns
+	for (int x = 0; x < 4; x++) {
+		for (int y = 0; y < 4; y++) {
+			cell_t temp = 0;
+			for (int j = 0; j < 4; j++) {
+				int b;
+				if (b = Q[4 * x + j]) {
+					cell_t a = k0_cell[4 * j + y];
+					temp ^= ((a << b) & 0x0F) | (a >> (4 - b));
+				}
+			}
+			k1_cell[4 * x + y] = temp;
+		}
+	}
+	qkey_t k1 = cell2text(k1_cell);
+
+	k0 ^= alpha;
+
+	text_t is = plaintext ^ w0;
+
+	for (int i = 0; i < rounds; i++) {
+		//printf("%d:\n", i);
+		is = forward(is, k0 ^ tweak ^ c[i], i);
+		tweak = forward_update_key(tweak);
+	}
+
+	//printf("0x%016llx\n", is);
+	is = forward(is, w1 ^ tweak, 1);
+	is = pseudo_reflect(is, k1);
+	is = backward(is, w0 ^ tweak, 1);
+
+	for (int i = rounds - 1; i >= 0; i--) {
+		//printf("%d:\n", i);
+		tweak = backward_update_key(tweak);
+		is = backward(is, k0 ^ tweak ^ c[i] ^ alpha, i);
+	}
+
+	is ^= w1;
+	//printf("0x%016llx\n", is);
+	return is;
+}
\ No newline at end of file
diff --git a/riscv/qarma.h b/riscv/qarma.h
new file mode 100644
index 00000000..aa02ef6a
--- /dev/null
+++ b/riscv/qarma.h
@@ -0,0 +1,35 @@
+#ifndef _RISCV_QARMA_H
+#define _RISCV_QARMA_H
+
+#define MAX_LENGTH 64
+#define subcells sbox[sbox_use]
+#define subcells_inv sbox_inv[sbox_use]
+
+typedef unsigned long long int const_t;
+typedef unsigned long long int tweak_t;
+typedef unsigned long long int text_t;
+typedef unsigned long long int qkey_t;
+typedef unsigned char          cell_t;
+
+void text2cell(cell_t* cell, text_t is);
+
+text_t cell2text(cell_t* cell);
+
+text_t pseudo_reflect(text_t is, qkey_t tk);
+
+text_t forward(text_t is, qkey_t tk, int r);
+
+text_t backward(text_t is, qkey_t tk, int r);
+
+cell_t LFSR(cell_t x);
+
+cell_t LFSR_inv(cell_t x);
+
+qkey_t forward_update_key(qkey_t T);
+
+qkey_t backward_update_key(qkey_t T);
+
+text_t qarma64_enc(text_t plaintext, tweak_t tweak, qkey_t w0, qkey_t k0, int rounds);
+text_t qarma64_dec(text_t plaintext, tweak_t tweak, qkey_t w0, qkey_t k0, int rounds);
+
+#endif
\ No newline at end of file
diff --git a/riscv/riscv.mk.in b/riscv/riscv.mk.in
index 31af737e..9de21d08 100644
--- a/riscv/riscv.mk.in
+++ b/riscv/riscv.mk.in
@@ -46,6 +46,7 @@ riscv_install_hdrs = \
 	trap.h \
 	triggers.h \
 	vector_unit.h \
+	qarma.h \
 
 riscv_precompiled_hdrs = \
 	insn_template.h \
@@ -74,6 +75,7 @@ riscv_srcs = \
 	vector_unit.cc \
 	socketif.cc \
 	cfg.cc \
+	qarma.cc \
 	$(riscv_gen_srcs) \
 
 riscv_test_srcs = \
@@ -135,6 +137,8 @@ riscv_insn_ext_i = \
 	xori \
 	fence \
 	fence_i \
+	crexk \
+	crdxk \
 
 riscv_insn_ext_a = \
 	amoadd_d \
